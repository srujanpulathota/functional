[CmdLetBinding()]
Param (
    [Parameter (Mandatory = $true)]
    [String] $SubscriptionName,
    [Parameter (Mandatory = $true)]
    [String] $ParameterFilePath,
    [Parameter(Mandatory = $false)]
    [String] $EndpointsFilePath
)

# Install and import Az module
Install-Module -Name Az -Scope CurrentUser -Force -AllowClobber
Import-Module -Name Az -Force
Install-Module -name az -Scope CurrentUser -Force
Import-Module -name az -Global -Force

# Login using SPN credentials
if ($SubscriptionName -eq 'Azure.IOTNPE') {
    $spnKey = $env:AZ_SERVICE_PRINCIPAL_PASSWORD
    $spnId  = $env:AZ_SERVICE_PRINCIPAL_ID
}
elseif ($SubscriptionName -eq 'Azure.IOTPROD') {
    $spnKey = $env:AZ_SERVICE_PRINCIPAL_PASSWORD_PROD
    $spnId  = $env:AZ_SERVICE_PRINCIPAL_ID_PROD
}

$tenantId        = $env:AZ_SERVICE_PRINCIPAL_TENANT
$SecuredPassword = ConvertTo-SecureString -String $spnKey -AsPlainText -Force
$Credential      = New-Object System.Management.Automation.PSCredential($spnId, $SecuredPassword)

Connect-AzAccount -ServicePrincipal -TenantId $tenantId -Credential $Credential
Select-AzSubscription -SubscriptionName $SubscriptionName

# Load parameter file
$appServices = Get-Content -Path $ParameterFilePath | ConvertFrom-Json
$reportPath  = "connectivity_report.csv"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# Load endpoints
if ($EndpointsFilePath) {
    $endpoints = (Import-Csv -Path $EndpointsFilePath).Endpoint
} else {
    Write-Host "❌ No endpoints file provided" -ForegroundColor Red
    exit 1
}

Write-Host "✅ Testing $($endpoints.Count) endpoints across $($appServices.appServices.Count) App Services."

# Create Runspace Pool
$runspacePool = [runspacefactory]::CreateRunspacePool(1, 15) # 15 threads max
$runspacePool.Open()
$jobs = @()

foreach ($appService in $appServices.appServices) {
    $appName       = $appService.name
    $resourceGroup = $appService.resourceGroup

    # Get Kudu credentials for this App Service
    $publishingProfile = Get-AzWebAppPublishingProfile -Name $appName -ResourceGroupName $resourceGroup -OutputFile null
    $xml      = [xml]$publishingProfile
    $userName = $xml.publishData.publishProfile[0].userName
    $password = $xml.publishData.publishProfile[0].userPWD
    $pair         = "${userName}:${password}"
    $encodedCreds = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes($pair))
    $headers      = @{ Authorization = "Basic $encodedCreds"; Accept = "application/json" }
    $kuduUrl      = "https://$appName.scm.azurewebsites.net/api/command?waitForExit=true&log=true"

    foreach ($endpoint in $endpoints) {

        # HARD FILTER: ignore .net endpoints completely – no test, no CSV row
        if ($endpoint -like "*.net*") {
            continue
        }

        $ps = [powershell]::Create()
        $ps.RunspacePool = $runspacePool

        $null = $ps.AddScript({
            param($endpoint, $headers, $kuduUrl, $appName, $resourceGroup)

            $status         = "Fail"
            $httpCode       = "000"
            $protocol       = ""
            $ErrorMessage   = ""
            $connectionInfo = ""
            $attempt        = 0
            $maxAttempts    = 3

            # Derive protocol
            if ($endpoint -match '^(https?)://') {
                $protocol = $Matches[1]
            }

            # Curl limits
            $connectTimeout = 3  # seconds for TCP connect
            $totalTimeout   = 5  # overall per-endpoint timeout

            while ($attempt -lt $maxAttempts) {
                $attempt++
                $status         = "Fail"
                $httpCode       = "000"
                $ErrorMessage   = ""
                $connectionInfo = ""
                $category       = ""
                $shouldRetry    = $true

                try {
                    # curl:
                    #  -skv        : ignore cert, silent + verbose (to see "Connected to")
                    #  -o /dev/null: discard body
                    #  --connect-timeout / --max-time: cap each attempt
                    #  2>&1        : send verbose to stdout for Kudu
                    #  -w ...      : metrics in one line
                    #  echo CURL_EXIT:$? : capture curl exit code
                    $command = "curl -skv -o /dev/null --connect-timeout $connectTimeout --max-time $totalTimeout " +
                               "-w `"HTTP_CODE:%{http_code} REMOTE_IP:%{remote_ip} TIME_NAMEL:%{time_namelookup} TIME_CONN:%{time_connect} TIME_TLS:%{time_appconnect} TIME_TTFB:%{time_starttransfer} TIME_TOTAL:%{time_total}`" " +
                               "$endpoint 2>&1; echo CURL_EXIT:`$?"

                    $body     = @{ command = $command; dir = "/home" } | ConvertTo-Json
                    $response = Invoke-RestMethod -Uri $kuduUrl -Method POST -Body $body -ContentType "application/json" -Headers $headers

                    $rawOutput = $response.Output -replace "`r","" -split "`n"

                    # Did we ever connect?
                    $connected = $false
                    if ($rawOutput -match '^\* Connected to ') {
                        $connected = $true
                    }

                    # Curl exit code
                    $curlExitLine = $rawOutput | Where-Object { $_ -match '^CURL_EXIT:' } | Select-Object -Last 1
                    $curlExitCode = -1
                    if ($curlExitLine) {
                        $curlExitCode = [int]($curlExitLine -replace '^CURL_EXIT:','' ).Trim()
                    }

                    # Metrics line
                    $metricsLine = $rawOutput | Where-Object { $_ -match '^HTTP_CODE:' } | Select-Object -Last 1
                    $remoteIp    = ""
                    [double]$timeConn  = 0
                    [double]$timeTotal = 0
                    [double]$timeNamel = 0
                    [double]$timeTls   = 0
                    [double]$timeTtfb  = 0

                    if ($metricsLine) {
                        if ($metricsLine -match 'HTTP_CODE:(\d{3})')      { $httpCode  = $Matches[1] }
                        if ($metricsLine -match 'REMOTE_IP:([^\s]+)')     { $remoteIp  = $Matches[1] }
                        if ($metricsLine -match 'TIME_NAMEL:([0-9.]+)')   { [double]$timeNamel = $Matches[1] }
                        if ($metricsLine -match 'TIME_CONN:([0-9.]+)')    { [double]$timeConn  = $Matches[1] }
                        if ($metricsLine -match 'TIME_TLS:([0-9.]+)')     { [double]$timeTls   = $Matches[1] }
                        if ($metricsLine -match 'TIME_TTFB:([0-9.]+)')    { [double]$timeTtfb  = $Matches[1] }
                        if ($metricsLine -match 'TIME_TOTAL:([0-9.]+)')   { [double]$timeTotal = $Matches[1] }
                    }

                    # ==============
                    # CLASSIFICATION
                    # ==============

                    if ($httpCode -ne "000") {
                        # Any HTTP code => TCP/TLS OK => egress reachable
                        $httpInt = 0
                        [void][int]::TryParse($httpCode, [ref]$httpInt)

                        if     ($httpInt -ge 200 -and $httpInt -lt 300) { $category = "HTTP_2XX" }
                        elseif ($httpInt -ge 300 -and $httpInt -lt 400) { $category = "HTTP_3XX" }
                        elseif ($httpInt -ge 400 -and $httpInt -lt 500) { $category = "HTTP_4XX" }
                        elseif ($httpInt -ge 500 -and $httpInt -lt 600) { $category = "HTTP_5XX" }
                        else                                             { $category = "HTTP_OTHER" }

                        # Your 404 example stays here: reachable ⇒ PASS
                        $status      = "Pass"
                        $shouldRetry = $false
                    }
                    else {
                        # HTTP 000 ⇒ check DNS text, connect flag, timings, exit code

                        # DNS resolution failure (trust the text if present)
                        if ($rawOutput -match 'Could not resolve host') {
                            $status      = "Fail"
                            $category    = "DNS_FAIL"
                            $shouldRetry = $false
                        }
                        # NO HTTP CODE + NO CONNECT ⇒ true network failure
                        elseif (-not $connected -and $timeConn -eq 0) {
                            switch ($curlExitCode) {
                                6 {
                                    $status      = "Fail"
                                    $category    = "DNS_FAIL"
                                    $shouldRetry = $false
                                }
                                7 {
                                    $status      = "Fail"
                                    $category    = "TCP_FAIL"
                                    $shouldRetry = ($attempt -lt $maxAttempts)
                                }
                                28 {
                                    $status      = "Fail"
                                    $category    = "CONNECT_TIMEOUT"
                                    $shouldRetry = ($attempt -lt $maxAttempts)
                                }
                                Default {
                                    $status      = "Fail"
                                    $category    = "UNKNOWN_BEFORE_CONNECT"
                                    $shouldRetry = ($attempt -lt $maxAttempts)
                                }
                            }
                        }
                        else {
                            # EDGE CASE ZONE:
                            # We KNOW we connected (either verbose says Connected or timeConn>0).
                            # This is your "first scenario" – egress is good.
                            switch ($curlExitCode) {
                                28 { $category = "CONNECT_OK_HTTP_TIMEOUT" } # connect ok, later timeout
                                35 { $category = "TLS_HANDSHAKE_FAIL" }
                                51 { $category = "TLS_CERT_FAIL" }
                                60 { $category = "TLS_CERT_FAIL" }
                                7  { $category = "TCP_FAIL_AFTER_CONNECT" }
                                Default { $category = "UNKNOWN_AFTER_CONNECT" }
                            }
                            $status      = "Pass"
                            $shouldRetry = $false
                        }
                    }

                    if ($status -eq "Fail") {
                        $ErrorMessage = ($rawOutput -join "`n")
                    }

                    $connectionInfo = "RemoteIp=$remoteIp; Category=$category; CurlExit=$curlExitCode; Connected=$connected; TimeConn=$timeConn; TimeTotal=$timeTotal"

                    if (-not $shouldRetry) {
                        break
                    } else {
                        Start-Sleep -Seconds 5
                    }
                }
                catch {
                    $ErrorMessage   = $_.Exception.Message
                    $status         = "Fail"
                    $category       = "EXCEPTION"
                    $connectionInfo = "Category=EXCEPTION; Message=$($ErrorMessage)"
                    if ($attempt -lt $maxAttempts) {
                        Start-Sleep -Seconds 5
                    } else {
                        break
                    }
                }
            }

            [PSCustomObject]@{
                AppService    = $appName
                ResourceGroup = $resourceGroup
                Endpoint      = $endpoint
                HTTPCode      = $httpCode
                Protocol      = $protocol
                Connection    = $connectionInfo
                Status        = $status
                ErrorMessage  = $ErrorMessage
                Timestamp     = (Get-Date).ToString("s")
            }
        }).AddArgument($endpoint).AddArgument($headers).AddArgument($kuduUrl).AddArgument($appName).AddArgument($resourceGroup)

        $jobs += [PSCustomObject]@{ Pipe = $ps; Handle = $ps.BeginInvoke() }
    }
}

# Collect results
$results = @()
$counter = 0
foreach ($job in $jobs) {
    $output = $job.Pipe.EndInvoke($job.Handle)
    $results += $output
    $job.Pipe.Dispose()
    $counter++
    if ($counter % 50 -eq 0) { Write-Host "Progress: $counter / $($jobs.Count) tests completed." }
}

# Close runspace pool
$runspacePool.Close()
$runspacePool.Dispose()

# Export results
$results | Export-Csv -Path $reportPath -NoTypeInformation
Write-Host "`n✅ Connectivity report generated at $reportPath"
