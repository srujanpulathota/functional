[CmdLetBinding()]
Param (
    [Parameter (Mandatory = $true)]
    [String] $SubscriptionName,
    [Parameter (Mandatory = $true)]
    [String] $ParameterFilePath,
    [Parameter(Mandatory = $false)]
    [String] $EndpointsFilePath
)

# Install and import Az module
Install-Module -Name Az -Scope CurrentUser -Force -AllowClobber
Import-Module -Name Az -Force
Install-Module -name az -Scope CurrentUser -Force
Import-Module -name az -Global -Force

# Login using SPN credentials
if ($SubscriptionName -eq 'Azure.IOTNPE') {
    $spnKey = $env:AZ_SERVICE_PRINCIPAL_PASSWORD
    $spnId  = $env:AZ_SERVICE_PRINCIPAL_ID
}
elseif ($SubscriptionName -eq 'Azure.IOTPROD') {
    $spnKey = $env:AZ_SERVICE_PRINCIPAL_PASSWORD_PROD
    $spnId  = $env:AZ_SERVICE_PRINCIPAL_ID_PROD
}

$tenantId        = $env:AZ_SERVICE_PRINCIPAL_TENANT
$SecuredPassword = ConvertTo-SecureString -String $spnKey -AsPlainText -Force
$Credential      = New-Object System.Management.Automation.PSCredential($spnId, $SecuredPassword)

Connect-AzAccount -ServicePrincipal -TenantId $tenantId -Credential $Credential
Select-AzSubscription -SubscriptionName $SubscriptionName

# Load parameter file
$appServices = Get-Content -Path $ParameterFilePath | ConvertFrom-Json
$reportPath  = "connectivity_report.csv"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# Load endpoints
if ($EndpointsFilePath) {
    $endpoints = (Import-Csv -Path $EndpointsFilePath).Endpoint
} else {
    Write-Host "❌ No endpoints file provided" -ForegroundColor Red
    exit 1
}

Write-Host "✅ Testing $($endpoints.Count) endpoints across $($appServices.appServices.Count) App Services."

# Create Runspace Pool
$runspacePool = [runspacefactory]::CreateRunspacePool(1, 15) # 15 threads max
$runspacePool.Open()
$jobs = @()

foreach ($appService in $appServices.appServices) {
    $appName       = $appService.name
    $resourceGroup = $appService.resourceGroup

    # Get Kudu credentials for this App Service
    $publishingProfile = Get-AzWebAppPublishingProfile -Name $appName -ResourceGroupName $resourceGroup -OutputFile null
    $xml      = [xml]$publishingProfile
    $userName = $xml.publishData.publishProfile[0].userName
    $password = $xml.publishData.publishProfile[0].userPWD
    $pair         = "${userName}:${password}"
    $encodedCreds = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes($pair))
    $headers      = @{ Authorization = "Basic $encodedCreds"; Accept = "application/json" }
    $kuduUrl      = "https://$appName.scm.azurewebsites.net/api/command?waitForExit=true&log=true"

    foreach ($endpoint in $endpoints) {
        $ps = [powershell]::Create()
        $ps.RunspacePool = $runspacePool

        $null = $ps.AddScript({
            param($endpoint, $headers, $kuduUrl, $appName, $resourceGroup)

            $status         = "Fail"
            $httpCode       = "000"
            $protocol       = ""
            $ErrorMessage   = ""
            $connectionInfo = ""
            $attempt        = 0
            $maxAttempts    = 3

            # Derive protocol from endpoint string
            if ($endpoint -match '^(https?)://') {
                $protocol = $Matches[1]
            }

            # Curl tunables – keep these small so we do not hang forever
            $connectTimeout = 3  # seconds for TCP connect
            $totalTimeout   = 5  # overall per-endpoint timeout

            while ($attempt -lt $maxAttempts) {
                $attempt++
                $status         = "Fail"
                $httpCode       = "000"
                $ErrorMessage   = ""
                $connectionInfo = ""
                $category       = ""
                $shouldRetry    = $true

                try {
                    # curl:
                    #  -k            : ignore cert validation (we care about reachability)
                    #  -sS -o /dev/null : silent, discard body
                    #  --connect-timeout / --max-time : bound each attempt
                    #  -w ...        : print metrics in a single line
                    # then echo CURL_EXIT:<code> from shell
                    $command = "curl -k -sS -o /dev/null --connect-timeout $connectTimeout --max-time $totalTimeout " +
                               "-w `"HTTP_CODE:%{http_code} REMOTE_IP:%{remote_ip} TIME_NAMEL:%{time_namelookup} TIME_CONN:%{time_connect} TIME_TLS:%{time_appconnect} TIME_TTFB:%{time_starttransfer} TIME_TOTAL:%{time_total}`" " +
                               "$endpoint; echo CURL_EXIT:`$?"

                    $body     = @{ command = $command; dir = "/home" } | ConvertTo-Json
                    $response = Invoke-RestMethod -Uri $kuduUrl -Method POST -Body $body -ContentType "application/json" -Headers $headers

                    # Normalize output lines
                    $rawOutput = $response.Output -replace "`r","" -split "`n"

                    # Parse curl exit code
                    $curlExitLine = $rawOutput | Where-Object { $_ -match '^CURL_EXIT:' } | Select-Object -Last 1
                    $curlExitCode = -1
                    if ($curlExitLine) {
                        $curlExitCode = [int]($curlExitLine -replace '^CURL_EXIT:','' ).Trim()
                    }

                    # Parse metrics line
                    $metricsLine = $rawOutput | Where-Object { $_ -match '^HTTP_CODE:' } | Select-Object -Last 1
                    $remoteIp    = ""
                    [double]$timeConn  = 0
                    [double]$timeTotal = 0
                    [double]$timeNamel = 0
                    [double]$timeTls   = 0
                    [double]$timeTtfb  = 0

                    if ($metricsLine) {
                        if ($metricsLine -match 'HTTP_CODE:(\d{3})')      { $httpCode  = $Matches[1] }
                        if ($metricsLine -match 'REMOTE_IP:([^\s]+)')     { $remoteIp  = $Matches[1] }
                        if ($metricsLine -match 'TIME_NAMEL:([0-9.]+)')   { [double]$timeNamel = $Matches[1] }
                        if ($metricsLine -match 'TIME_CONN:([0-9.]+)')    { [double]$timeConn  = $Matches[1] }
                        if ($metricsLine -match 'TIME_TLS:([0-9.]+)')     { [double]$timeTls   = $Matches[1] }
                        if ($metricsLine -match 'TIME_TTFB:([0-9.]+)')    { [double]$timeTtfb  = $Matches[1] }
                        if ($metricsLine -match 'TIME_TOTAL:([0-9.]+)')   { [double]$timeTotal = $Matches[1] }
                    }

                    $endpointHasDotNet = $endpoint -like "*.net*"

                    # =========================
                    # CLASSIFICATION LOGIC
                    # =========================

                    if ($httpCode -ne "000") {
                        # Any HTTP code means: TCP + (if https) TLS succeeded.
                        # For egress, that is reachable.

                        $httpInt = 0
                        [void][int]::TryParse($httpCode, [ref]$httpInt)

                        if ($httpInt -ge 200 -and $httpInt -lt 300) {
                            $category = "HTTP_2XX"
                        }
                        elseif ($httpInt -ge 300 -and $httpInt -lt 400) {
                            $category = "HTTP_3XX"
                        }
                        elseif ($httpInt -ge 400 -and $httpInt -lt 500) {
                            $category = "HTTP_4XX"
                        }
                        elseif ($httpInt -ge 500 -and $httpInt -lt 600) {
                            $category = "HTTP_5XX"
                        }
                        else {
                            $category = "HTTP_OTHER"
                        }

                        # Special handling for 403 – Pass only if endpoint contains .net
                        if ($httpCode -eq "403" -and -not $endpointHasDotNet) {
                            $status      = "Fail"
                            $shouldRetry = $false
                        } else {
                            # Your 404 example falls here: PASS.
                            $status      = "Pass"
                            $shouldRetry = $false
                        }
                    }
                    else {
                        # HTTP 000 – need to look at curl exit code + timings
                        if ($rawOutput -match 'Could not resolve host') {
                            $status      = "Fail"
                            $category    = "DNS_FAIL"
                            $shouldRetry = $false
                        }
                        else {
                            switch ($curlExitCode) {
                                0 {
                                    # Exit 0 but code 000 is rare.
                                    if ($timeConn -gt 0) {
                                        $status      = "Pass"
                                        $category    = "CONNECT_OK_NO_HTTP_CODE"
                                        $shouldRetry = $false
                                    } else {
                                        $status      = "Fail"
                                        $category    = "UNKNOWN_BEFORE_CONNECT"
                                        $shouldRetry = $false
                                    }
                                }
                                6 {
                                    $status      = "Fail"
                                    $category    = "DNS_FAIL"
                                    $shouldRetry = $false
                                }
                                7 {
                                    if ($timeConn -gt 0) {
                                        # Connected but failed after that – infra behavior but egress proven.
                                        $status      = "Pass"
                                        $category    = "TCP_FAIL_AFTER_CONNECT"
                                        $shouldRetry = $false
                                    } else {
                                        $status      = "Fail"
                                        $category    = "TCP_FAIL"
                                        $shouldRetry = ($attempt -lt $maxAttempts)
                                    }
                                }
                                28 {
                                    if ($timeConn -gt 0) {
                                        # First scenario: TCP connect ok, later timeout.
                                        $status      = "Pass"
                                        $category    = "CONNECT_OK_HTTP_TIMEOUT"
                                        $shouldRetry = $false
                                    } else {
                                        # Second scenario: connect timeout (never got a socket).
                                        $status      = "Fail"
                                        $category    = "CONNECT_TIMEOUT"
                                        $shouldRetry = ($attempt -lt $maxAttempts)
                                    }
                                }
                                35 {
                                    # TLS handshake fail – we reached the host; treat as reachable but abnormal
                                    $status      = "Pass"
                                    $category    = "TLS_HANDSHAKE_FAIL"
                                    $shouldRetry = $false
                                }
                                51 { # cert verify failed
                                    $status      = "Pass"
                                    $category    = "TLS_CERT_FAIL"
                                    $shouldRetry = $false
                                }
                                60 { # cert verify failed
                                    $status      = "Pass"
                                    $category    = "TLS_CERT_FAIL"
                                    $shouldRetry = $false
                                }
                                Default {
                                    if ($timeConn -gt 0) {
                                        # Anything failing after connect – egress is good.
                                        $status      = "Pass"
                                        $category    = "UNKNOWN_AFTER_CONNECT"
                                        $shouldRetry = $false
                                    } else {
                                        $status      = "Fail"
                                        $category    = "UNKNOWN_BEFORE_CONNECT"
                                        $shouldRetry = ($attempt -lt $maxAttempts)
                                    }
                                }
                            }
                        }
                    }

                    if ($status -eq "Fail") {
                        $ErrorMessage = ($rawOutput -join "`n")
                    }

                    # Build connection info metadata for CSV
                    $connectionInfo = "RemoteIp=$remoteIp; Category=$category; CurlExit=$curlExitCode; TimeConn=$timeConn; TimeTotal=$timeTotal"

                    if (-not $shouldRetry) {
                        break
                    } else {
                        Start-Sleep -Seconds 5
                    }
                }
                catch {
                    $ErrorMessage   = $_.Exception.Message
                    $status         = "Fail"
                    $category       = "EXCEPTION"
                    $connectionInfo = "Category=EXCEPTION; Message=$($ErrorMessage)"
                    if ($attempt -lt $maxAttempts) {
                        Start-Sleep -Seconds 5
                    } else {
                        break
                    }
                }
            }

            [PSCustomObject]@{
                AppService    = $appName
                ResourceGroup = $resourceGroup
                Endpoint      = $endpoint
                HTTPCode      = $httpCode
                Protocol      = $protocol
                Connection    = $connectionInfo
                Status        = $status
                ErrorMessage  = $ErrorMessage
                Timestamp     = (Get-Date).ToString("s")
            }
        }).AddArgument($endpoint).AddArgument($headers).AddArgument($kuduUrl).AddArgument($appName).AddArgument($resourceGroup)

        $jobs += [PSCustomObject]@{ Pipe = $ps; Handle = $ps.BeginInvoke() }
    }
}

# Collect results
$results = @()
$counter = 0
foreach ($job in $jobs) {
    $output = $job.Pipe.EndInvoke($job.Handle)
    $results += $output
    $job.Pipe.Dispose()
    $counter++
    if ($counter % 50 -eq 0) { Write-Host "Progress: $counter / $($jobs.Count) tests completed." }
}

# Close runspace pool
$runspacePool.Close()
$runspacePool.Dispose()

# Export results
$results | Export-Csv -Path $reportPath -NoTypeInformation
Write-Host "`n✅ Connectivity report generated at $reportPath"
