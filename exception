[CmdLetBinding()]
Param (
    [Parameter (Mandatory = $true)]
    [String] $SubscriptionName,

    [Parameter (Mandatory = $true)]
    [String] $ParameterFilePath,

    [Parameter (Mandatory = $false)]
    [String] $ReportPath = "connectivity_report.csv"
)

# ============================================================================================
# GLOBAL SETTINGS
# ============================================================================================
$ErrorActionPreference = "Stop"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

Write-Host "================ AppService Egress Connectivity Check ================" -ForegroundColor Cyan
Write-Host "Subscription : $SubscriptionName"
Write-Host "Param file   : $ParameterFilePath"
Write-Host "Report path  : $ReportPath"
Write-Host "=======================================================================" -ForegroundColor Cyan

# ============================================================================================
# MODULES
# ============================================================================================
try {
    Write-Host "[INIT] Loading Az modules..." -ForegroundColor Cyan
    Install-Module -Name Az -Scope CurrentUser -Force -AllowClobber | Out-Null
    Import-Module  -Name Az -Force
}
catch {
    Write-Host "[ERROR] Failed to install/import Az modules: $($_.Exception.Message)" -ForegroundColor Red
    exit 1
}

# ============================================================================================
# AUTHENTICATION (AZURE SPN)
# ============================================================================================
try {
    Write-Host "[AUTH] Authenticating to Azure subscription '$SubscriptionName'..." -ForegroundColor Cyan

    switch ($SubscriptionName) {
        "Azure.IOTNPE" {
            $spnKey = $env:AZ_SERVICE_PRINCIPAL_PASSWORD
            $spnId  = $env:AZ_SERVICE_PRINCIPAL_ID
        }
        "Azure.IOTPROD" {
            $spnKey = $env:AZ_SERVICE_PRINCIPAL_PASSWORD_PROD
            $spnId  = $env:AZ_SERVICE_PRINCIPAL_ID_PROD
        }
        default {
            throw "Unsupported SubscriptionName '$SubscriptionName'. Extend SPN mapping in script."
        }
    }

    $tenantId = $env:AZ_SERVICE_PRINCIPAL_TENANT
    if (-not $spnKey -or -not $spnId -or -not $tenantId) {
        throw "SPN environment variables are not fully set. Check AZ_SERVICE_PRINCIPAL_* variables."
    }

    $securePw = ConvertTo-SecureString $spnKey -AsPlainText -Force
    $cred     = New-Object System.Management.Automation.PSCredential($spnId, $securePw)

    Connect-AzAccount -ServicePrincipal -TenantId $tenantId -Credential $cred | Out-Null
    Select-AzSubscription -SubscriptionName $SubscriptionName | Out-Null

    Write-Host "[AUTH] Azure authentication succeeded." -ForegroundColor Green
}
catch {
    Write-Host "[ERROR] Azure authentication failed: $($_.Exception.Message)" -ForegroundColor Red
    exit 1
}

# ============================================================================================
# HELPER: Extract URLs from arbitrary text (regex based)
# ============================================================================================
function Get-UrlsFromText {
    param(
        [Parameter(Mandatory = $true)] [string] $Text
    )

    # Basic http(s) URL regex – no YAML assumptions
    $pattern = 'https?://[^\s''""]+'

    $matches = [System.Text.RegularExpressions.Regex]::Matches($Text, $pattern)
    if (-not $matches -or $matches.Count -eq 0) {
        return @()
    }

    $urls = $matches |
        ForEach-Object {
            # Trim trailing punctuation that often sticks to URLs in config
            $_.Value.TrimEnd('.', ',', ';', ')', ']', '}')
        } |
        Where-Object { $_ -ne "" } |
        Select-Object -Unique

    return $urls
}

# ============================================================================================
# HELPER: Fetch YAML via direct GitLab file URL + extract URLs
# ============================================================================================
function Get-EndpointsFromGitLabFileUrl {
    param(
        [Parameter(Mandatory = $true)] [string] $FileUrl,

        # Optional: CI/CD variable holding PAT (e.g. GITLAB_ACCESS_TOKEN)
        [Parameter(Mandatory = $false)] [string] $TokenEnvVar
    )

    Write-Host "  [YAML] Source URL (blob):" -ForegroundColor Cyan
    Write-Host "         $FileUrl" -ForegroundColor Cyan

    # 1) Convert blob URL -> raw URL
    $rawUrl = $FileUrl
    if ($rawUrl -match "/-/blob/") {
        $rawUrl = $rawUrl -replace "/-/blob/", "/-/raw/"
    }
    Write-Host "  [YAML] Raw URL used for download:" -ForegroundColor DarkCyan
    Write-Host "         $rawUrl" -ForegroundColor DarkCyan

    # 2) Build headers (optional token)
    $headers = @{}
    if ($TokenEnvVar) {
        $tokenValue = (Get-Item -Path "Env:$TokenEnvVar" -ErrorAction SilentlyContinue).Value
        if (-not $tokenValue) {
            throw "[YAML] Environment variable '$TokenEnvVar' not set. Cannot authenticate to GitLab."
        }

        $headers["PRIVATE-TOKEN"] = $tokenValue
        Write-Host "  [YAML] Using PAT from CI/CD variable '$TokenEnvVar' (PRIVATE-TOKEN)" -ForegroundColor DarkCyan
    }
    else {
        Write-Host "  [YAML] No tokenEnvVar specified. Attempting anonymous access." -ForegroundColor DarkCyan
    }

    # 3) Download raw content
    $yamlText = $null
    try {
        Write-Host "  [YAML] Downloading content..." -ForegroundColor DarkCyan
        $yamlText = Invoke-RestMethod -Uri $rawUrl -Headers $headers -Method GET
        Write-Host "  [YAML] Download succeeded. Size: $($yamlText.Length) characters." -ForegroundColor Green
    }
    catch {
        $statusCode = $null
        $statusDesc = $null

        if ($_.Exception.Response -ne $null) {
            $statusCode = [int]$_.Exception.Response.StatusCode
            $statusDesc = $_.Exception.Response.StatusDescription
        }

        if ($statusCode) {
            throw "[YAML] Failed to fetch content from '$rawUrl' (HTTP $statusCode $statusDesc): $($_.Exception.Message)"
        }
        else {
            throw "[YAML] Failed to fetch content from '$rawUrl': $($_.Exception.Message)"
        }
    }

    if (-not $yamlText -or $yamlText.Trim().Length -eq 0) {
        throw "[YAML] Downloaded content is empty."
    }

    # 4) Extract URLs from plain text (structure-agnostic)
    Write-Host "  [YAML] Extracting URLs from content (regex-based)..." -ForegroundColor DarkCyan
    $urls = Get-UrlsFromText -Text $yamlText

    if (-not $urls -or $urls.Count -eq 0) {
        throw "[YAML] No URLs found in the downloaded content."
    }

    Write-Host "  [YAML] Found $($urls.Count) unique URL(s):" -ForegroundColor Green
    foreach ($u in $urls) {
        Write-Host "         - $u" -ForegroundColor Green
    }

    return $urls
}

# ============================================================================================
# LOAD PARAMETER FILE
# ============================================================================================
$config = $null
try {
    Write-Host "[CONFIG] Loading parameter file: $ParameterFilePath" -ForegroundColor Cyan
    $config = Get-Content -Path $ParameterFilePath -Raw | ConvertFrom-Json -Depth 100
    Write-Host "[CONFIG] Loaded $(($config.appServices).Count) appService definition(s)." -ForegroundColor Green
}
catch {
    Write-Host "[ERROR] Failed to load/parse parameter file '$ParameterFilePath': $($_.Exception.Message)" -ForegroundColor Red
    exit 1
}

$results        = New-Object System.Collections.Generic.List[object]
$overallSuccess = $true

# ============================================================================================
# MAIN LOOP: APP SERVICE → YAML (URL) → ENDPOINTS → KUDU CURL
# ============================================================================================
foreach ($app in $config.appServices) {

    Write-Host ""
    Write-Host "===============================" -ForegroundColor DarkCyan
    Write-Host "AppService    : $($app.name)"          -ForegroundColor DarkCyan
    Write-Host "Resource Group: $($app.resourceGroup)" -ForegroundColor DarkCyan
    Write-Host "===============================" -ForegroundColor DarkCyan

    if ($app.PSObject.Properties.Name -contains 'endpoints') {
        Write-Host "[WARN] AppService '$($app.name)' still has 'endpoints' in JSON. This is ignored (GitLab YAML is the only source)." -ForegroundColor Yellow
    }

    if (-not $app.endpointSource) {
        Write-Host "[ERROR] AppService '$($app.name)' is missing 'endpointSource' block. Skipping." -ForegroundColor Red
        $overallSuccess = $false
        continue
    }

    $src = $app.endpointSource

    if (-not $src.fileUrl) {
        Write-Host "[ERROR] AppService '$($app.name)': endpointSource must contain 'fileUrl' with the GitLab YAML URL. Skipping." -ForegroundColor Red
        $overallSuccess = $false
        continue
    }

    $tokenEnvVar = $null
    if ($src.PSObject.Properties.Name -contains 'tokenEnvVar' -and $src.tokenEnvVar) {
        $tokenEnvVar = $src.tokenEnvVar
    }

    # -------------------------------------------------------------------------
    # Resolve endpoints from GitLab URL
    # -------------------------------------------------------------------------
    $endpoints = @()
    try {
        $endpoints = Get-EndpointsFromGitLabFileUrl `
                        -FileUrl    $src.fileUrl `
                        -TokenEnvVar $tokenEnvVar
    }
    catch {
        Write-Host "❌ [APP] Failed to resolve endpoints for '$($app.name)': $($_.Exception.Message)" -ForegroundColor Red
        $overallSuccess = $false
        continue
    }

    # -------------------------------------------------------------------------
    # Get Kudu publishing profile
    # -------------------------------------------------------------------------
    $uname = $null
    $pwd   = $null
    try {
        Write-Host "[KUDU] Fetching publishing profile for '$($app.name)'..." -ForegroundColor Cyan
        $profile = Get-AzWebAppPublishingProfile -Name $app.name -ResourceGroupName $app.resourceGroup -OutputFile $null
        $xml     = [xml]$profile
        $uname   = $xml.publishData.publishProfile[0].userName
        $pwd     = $xml.publishData.publishProfile[0].userPWD
        Write-Host "[KUDU] Publishing profile retrieved." -ForegroundColor Green
    }
    catch {
        Write-Host "❌ [KUDU] Failed to get publishing profile for '$($app.name)': $($_.Exception.Message)" -ForegroundColor Red
        $overallSuccess = $false
        continue
    }

    $pair    = "$uname`:$pwd"
    $auth    = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes($pair))
    $headers = @{
        Authorization = "Basic $auth"
        Accept        = "application/json"
    }
    $kuduUrl = "https://$($app.name).scm.azurewebsites.net/api/command?waitForExit=true&log=true"

    Write-Host "[KUDU] Using URL: $kuduUrl" -ForegroundColor DarkCyan

    # -------------------------------------------------------------------------
    # Test each endpoint via Kudu + curl
    # -------------------------------------------------------------------------
    foreach ($url in $endpoints) {
        $attempt   = 0
        $max       = 3
        $status    = "Fail"
        $httpCode  = ""
        $errorMsg  = $null

        Write-Host "[TEST] Checking endpoint: $url" -ForegroundColor Cyan

        while ($attempt -lt $max) {
            $attempt++

            try {
                $cmd  = "curl -k -s -o /dev/null -w '%{http_code}' $url"
                $body = @{ command = $cmd; dir = "/home" } | ConvertTo-Json

                $resp     = Invoke-RestMethod -Uri $kuduUrl -Method POST -Body $body -ContentType "application/json" -Headers $headers
                $httpCode = ($resp.Output -replace "[^0-9]", "")

                if ($httpCode -in @("200", "404", "401")) {
                    $status = "Pass"
                    Write-Host "  ✔ $url : HTTP $httpCode (attempt $attempt)" -ForegroundColor Green
                    break
                }
                else {
                    $status   = "Fail"
                    $errorMsg = "Unexpected HTTP code $httpCode"
                    Write-Host "  ✖ $url : HTTP $httpCode (attempt $attempt)" -ForegroundColor Yellow
                }
            }
            catch {
                $status   = "Fail"
                $errorMsg = $_.Exception.Message
                Write-Host "  ✖ $url : Exception on attempt $attempt -> $errorMsg" -ForegroundColor Red
            }

            if ($attempt -lt $max) {
                Write-Host "  ...retrying in 5 seconds (attempt $($attempt + 1) of $max)..." -ForegroundColor DarkYellow
                Start-Sleep -Seconds 5
            }
        }

        if ($status -ne "Pass") {
            $overallSuccess = $false
        }

        $results.Add([pscustomobject]@{
            AppService    = $app.name
            ResourceGroup = $app.resourceGroup
            Endpoint      = $url
            HTTPCode      = $httpCode
            Status        = $status
            Attempts      = $attempt
            Error         = $errorMsg
            Timestamp     = (Get-Date).ToString("s")
        })
    }
}

# ============================================================================================
# REPORT + EXIT CODE
# ============================================================================================
try {
    $results | Export-Csv -Path $ReportPath -NoTypeInformation
    Write-Host "`n[REPORT] Connectivity report generated at: $ReportPath" -ForegroundColor Cyan
}
catch {
    Write-Host "[ERROR] Failed to write report to '$ReportPath': $($_.Exception.Message)" -ForegroundColor Red
    # even if CSV fails, still set correct exit code below
}

if (-not $overallSuccess) {
    Write-Host "[RESULT] One or more endpoints FAILED connectivity checks." -ForegroundColor Red
    exit 1
}
else {
    Write-Host "[RESULT] All endpoints PASSED connectivity checks." -ForegroundColor Green
    exit 0
}
