[CmdLetBinding()]
Param (
    [Parameter (Mandatory = $true)]
    [String] $SubscriptionName,

    [Parameter (Mandatory = $true)]
    [String] $ParameterFilePath,

    [Parameter (Mandatory = $false)]
    [String] $ReportPath = "connectivity_report.csv"
)

# ============================================================================================
# GLOBAL SETTINGS
# ============================================================================================
$ErrorActionPreference = "Stop"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# ============================================================================================
# MODULES
# ============================================================================================
Write-Host "Loading Az modules..." -ForegroundColor Cyan
Install-Module -Name Az -Scope CurrentUser -Force -AllowClobber | Out-Null
Import-Module  -Name Az -Force

Write-Host "Loading YAML module..." -ForegroundColor Cyan
Install-Module powershell-yaml -Scope CurrentUser -Force | Out-Null
Import-Module powershell-yaml

Add-Type -AssemblyName System.Web

# ============================================================================================
# AUTHENTICATION (AZURE SPN)
# ============================================================================================
Write-Host "Authenticating to Azure subscription '$SubscriptionName'..." -ForegroundColor Cyan

switch ($SubscriptionName) {
    "Azure.IOTNPE" {
        $spnKey = $env:AZ_SERVICE_PRINCIPAL_PASSWORD
        $spnId  = $env:AZ_SERVICE_PRINCIPAL_ID
    }
    "Azure.IOTPROD" {
        $spnKey = $env:AZ_SERVICE_PRINCIPAL_PASSWORD_PROD
        $spnId  = $env:AZ_SERVICE_PRINCIPAL_ID_PROD
    }
    default {
        throw "Unsupported SubscriptionName '$SubscriptionName'. Extend SPN mapping in script."
    }
}

$tenantId = $env:AZ_SERVICE_PRINCIPAL_TENANT
if (-not $spnKey -or -not $spnId -or -not $tenantId) {
    throw "SPN environment variables are not fully set. Check AZ_SERVICE_PRINCIPAL_* variables."
}

$securePw = ConvertTo-SecureString $spnKey -AsPlainText -Force
$cred     = New-Object System.Management.Automation.PSCredential($spnId, $securePw)

Connect-AzAccount -ServicePrincipal -TenantId $tenantId -Credential $cred | Out-Null
Select-AzSubscription -SubscriptionName $SubscriptionName | Out-Null

# ============================================================================================
# YAML URL DISCOVERY HELPERS
# ============================================================================================
function Get-UrlsFromYamlObject {
    param(
        [Parameter(Mandatory = $true)] $Node,
        [Parameter(Mandatory = $true)] [ValidateSet("AnyHttpString", "ByKey")] [string] $Mode,
        [Parameter(Mandatory = $false)] [string] $UrlKey
    )

    $collected = @()

    if ($null -eq $Node) {
        return $collected
    }

    # Hashtable / dictionary node
    if ($Node -is [System.Collections.IDictionary]) {
        foreach ($key in $Node.Keys) {
            $value = $Node[$key]

            if ($Mode -eq "ByKey" -and $key -eq $UrlKey -and $value -is [string]) {
                if ($value -match '^https?://') {
                    $collected += $value
                }
            }

            # Recurse into value
            $collected += Get-UrlsFromYamlObject -Node $value -Mode $Mode -UrlKey $UrlKey
        }
        return $collected
    }

    # Array / list (excluding strings)
    if ($Node -is [System.Collections.IEnumerable] -and -not ($Node -is [string])) {
        foreach ($item in $Node) {
            $collected += Get-UrlsFromYamlObject -Node $item -Mode $Mode -UrlKey $UrlKey
        }
        return $collected
    }

    # Leaf string
    if ($Node -is [string]) {
        if ($Mode -eq "AnyHttpString" -and $Node -match '^https?://') {
            $collected += $Node
        }
        return $collected
    }

    return $collected
}

function Get-EndpointsFromGitLabFileUrl {
    param(
        [Parameter(Mandatory = $true)] [string] $FileUrl,

        # Name of CI/CD variable that holds a PAT (e.g. GITLAB_ACCESS_TOKEN). Optional.
        [Parameter(Mandatory = $false)] [string] $TokenEnvVar,

        [Parameter(Mandatory = $false)] [ValidateSet("AnyHttpString", "ByKey")] [string] $DetectionMode = "AnyHttpString",
        [Parameter(Mandatory = $false)] [string] $UrlKey = "url"
    )

    Write-Host "  Pulling YAML endpoints from GitLab URL:" -ForegroundColor Cyan
    Write-Host "    $FileUrl" -ForegroundColor Cyan

    # ----------------------------------------------------------------------------------------
    # 1) Convert blob URL -> raw URL
    # ----------------------------------------------------------------------------------------
    $rawUrl = $FileUrl

    if ($rawUrl -match "/-/blob/") {
        $rawUrl = $rawUrl -replace "/-/blob/", "/-/raw/"
    }

    Write-Host "  Using raw YAML URL:" -ForegroundColor DarkCyan
    Write-Host "    $rawUrl" -ForegroundColor DarkCyan

    # ----------------------------------------------------------------------------------------
    # 2) Optional PAT header (PRIVATE-TOKEN) if TokenEnvVar is provided and set
    # ----------------------------------------------------------------------------------------
    $headers = @{}

    if ($TokenEnvVar) {
        $tokenValue = (Get-Item -Path "Env:$TokenEnvVar" -ErrorAction SilentlyContinue).Value
        if (-not $tokenValue) {
            throw "Environment variable '$TokenEnvVar' not set. Cannot authenticate to GitLab."
        }

        $headers["PRIVATE-TOKEN"] = $tokenValue
        Write-Host "  Using PAT from CI/CD variable '$TokenEnvVar' (header: PRIVATE-TOKEN)" -ForegroundColor DarkCyan
    }
    else {
        Write-Host "  No tokenEnvVar provided. Fetching YAML without authentication." -ForegroundColor DarkCyan
    }

    # ----------------------------------------------------------------------------------------
    # 3) Get raw YAML file content
    # ----------------------------------------------------------------------------------------
    try {
        $yamlText = Invoke-RestMethod -Uri $rawUrl -Headers $headers -Method GET
    }
    catch {
        $statusCode = $null
        $statusDesc = $null

        if ($_.Exception.Response -ne $null) {
            $statusCode = [int]$_.Exception.Response.StatusCode
            $statusDesc = $_.Exception.Response.StatusDescription
        }

        if ($statusCode) {
            throw "Failed to fetch YAML from '$rawUrl' (HTTP $statusCode $statusDesc): $($_.Exception.Message)"
        }
        else {
            throw "Failed to fetch YAML from '$rawUrl': $($_.Exception.Message)"
        }
    }

    if (-not $yamlText) {
        throw "YAML from '$rawUrl' is empty."
    }

    # ----------------------------------------------------------------------------------------
    # 4) Parse YAML + extract endpoints
    # ----------------------------------------------------------------------------------------
    try {
        $yamlObj = ConvertFrom-Yaml -Yaml $yamlText
    }
    catch {
        throw "Failed to parse YAML content from '$rawUrl': $($_.Exception.Message)"
    }

    $urls = Get-UrlsFromYamlObject -Node $yamlObj -Mode $DetectionMode -UrlKey $UrlKey |
            Select-Object -Unique

    if (-not $urls -or $urls.Count -eq 0) {
        throw "No endpoints discovered in YAML from '$rawUrl' using mode '$DetectionMode' (UrlKey='$UrlKey')."
    }

    Write-Host "  ✔ Extracted $($urls.Count) endpoint(s) from YAML" -ForegroundColor Green
    return $urls
}

# ============================================================================================
# LOAD PARAMETER FILE
# ============================================================================================
Write-Host "Loading parameter file: $ParameterFilePath" -ForegroundColor Cyan
$config = Get-Content -Path $ParameterFilePath -Raw | ConvertFrom-Json -Depth 100

$results        = New-Object System.Collections.Generic.List[object]
$overallSuccess = $true

# ============================================================================================
# MAIN LOOP: APP SERVICE → GITLAB YAML (URL) → ENDPOINTS → KUDU CURL
# ============================================================================================
foreach ($app in $config.appServices) {

    Write-Host "`n===============================" -ForegroundColor DarkCyan
    Write-Host "AppService    : $($app.name)"          -ForegroundColor DarkCyan
    Write-Host "Resource Group: $($app.resourceGroup)" -ForegroundColor DarkCyan
    Write-Host "===============================" -ForegroundColor DarkCyan

    if ($app.PSObject.Properties.Name -contains 'endpoints') {
        throw "AppService '$($app.name)' still has 'endpoints' defined. Legacy inline endpoints are not supported."
    }

    if (-not $app.endpointSource) {
        throw "AppService '$($app.name)' is missing 'endpointSource' block. This is mandatory."
    }

    $src = $app.endpointSource

    if (-not $src.fileUrl) {
        throw "AppService '$($app.name)': endpointSource must contain 'fileUrl' with the GitLab YAML URL."
    }

    # urlDetection defaults
    $detectionMode = "AnyHttpString"
    $urlKey        = "url"

    if ($src.PSObject.Properties.Name -contains 'urlDetection' -and $src.urlDetection) {
        if ($src.urlDetection.mode)   { $detectionMode = $src.urlDetection.mode }
        if ($src.urlDetection.urlKey) { $urlKey        = $src.urlDetection.urlKey }
    }

    # tokenEnvVar (optional)
    $tokenEnvVar = $null
    if ($src.PSObject.Properties.Name -contains 'tokenEnvVar' -and $src.tokenEnvVar) {
        $tokenEnvVar = $src.tokenEnvVar
    }

    # Get endpoints from GitLab via direct URL
    try {
        $endpoints = Get-EndpointsFromGitLabFileUrl `
                        -FileUrl      $src.fileUrl `
                        -TokenEnvVar  $tokenEnvVar `
                        -DetectionMode $detectionMode `
                        -UrlKey        $urlKey
    }
    catch {
        Write-Host "❌ Failed to resolve endpoints for '$($app.name)': $($_.Exception.Message)" -ForegroundColor Red
        $overallSuccess = $false
        continue
    }

    # Get Kudu publishing profile
    try {
        $profile = Get-AzWebAppPublishingProfile -Name $app.name -ResourceGroupName $app.resourceGroup -OutputFile $null
        $xml     = [xml]$profile
        $uname   = $xml.publishData.publishProfile[0].userName
        $pwd     = $xml.publishData.publishProfile[0].userPWD
    }
    catch {
        Write-Host "❌ Failed to get Kudu publishing profile for '$($app.name)': $($_.Exception.Message)" -ForegroundColor Red
        $overallSuccess = $false
        continue
    }

    # Prepare Kudu auth
    $pair    = "$uname`:$pwd"
    $auth    = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes($pair))
    $headers = @{
        Authorization = "Basic $auth"
        Accept        = "application/json"
    }
    $kuduUrl = "https://$($app.name).scm.azurewebsites.net/api/command?waitForExit=true&log=true"

    # Test each endpoint
    foreach ($url in $endpoints) {
        $attempt   = 0
        $max       = 3
        $status    = "Fail"
        $httpCode  = ""
        $errorMsg  = $null

        while ($attempt -lt $max) {
            $attempt++

            try {
                $cmd  = "curl -k -s -o /dev/null -w '%{http_code}' $url"
                $body = @{ command = $cmd; dir = "/home" } | ConvertTo-Json

                $resp     = Invoke-RestMethod -Uri $kuduUrl -Method POST -Body $body -ContentType "application/json" -Headers $headers
                $httpCode = ($resp.Output -replace "[^0-9]", "")

                if ($httpCode -in @("200", "404", "401")) {
                    $status = "Pass"
                    Write-Host "✔ $url : HTTP $httpCode (attempt $attempt)" -ForegroundColor Green
                    break
                }
                else {
                    $status   = "Fail"
                    $errorMsg = "Unexpected HTTP code $httpCode"
                    Write-Host "✖ $url : HTTP $httpCode (attempt $attempt)" -ForegroundColor Red
                }
            }
            catch {
                $status   = "Fail"
                $errorMsg = $_.Exception.Message
                Write-Host "✖ $url : $errorMsg (attempt $attempt)" -ForegroundColor Red
            }

            Start-Sleep -Seconds 5
        }

        if ($status -ne "Pass") {
            $overallSuccess = $false
        }

        $results.Add([pscustomobject]@{
            AppService    = $app.name
            ResourceGroup = $app.resourceGroup
            Endpoint      = $url
            HTTPCode      = $httpCode
            Status        = $status
            Attempts      = $attempt
            Error         = $errorMsg
            Timestamp     = (Get-Date).ToString("s")
        })
    }
}

# ============================================================================================
# REPORT + EXIT CODE
# ============================================================================================
$results | Export-Csv -Path $ReportPath -NoTypeInformation
Write-Host "`nConnectivity report generated at: $ReportPath" -ForegroundColor Cyan

if (-not $overallSuccess) {
    Write-Host "❌ One or more endpoints failed connectivity checks." -ForegroundColor Red
    exit 1
}
else {
    Write-Host "✔ All endpoints passed connectivity checks." -ForegroundColor Green
    exit 0
}
